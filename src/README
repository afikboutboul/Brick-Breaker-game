afik.boutboul
315210799

1) In this section, I chose option 2 - sending an instance of BrickerGameManager to the constructor of
   BasicCollisionStrategy.
   Advantages:
   1. Encapsulation: By entrusting the responsibility of object addition and removal solely to the
   BrickerGameManager class, we adhere to the principle of encapsulation,
   where the internal workings of the class remain hidden from external classes,
   promoting data integrity and security.
   2. Abstraction: The second option abstracts away the implementation details of object management
   from the BasicCollisionStrategy class, allowing it to focus solely on collision handling logic.
   This abstraction simplifies the design, making it easier to understand and maintain.
   3. Polymorphism: Through the use of polymorphism, the BasicCollisionStrategy class can interact
   with various CollisionStrategy objects generated by BrickerGameManager,
   enabling flexibility and adaptability in handling different collision scenarios.

   Disadvantages:
   1. Dependency and Tight Coupling: This approach introduces a tight coupling between
   BasicCollisionStrategy and BrickerGameManager, potentially limiting the reusability
   and testability of the former. Changes in BrickerGameManager's implementation may
   cascade into modifications in BasicCollisionStrategy,
   violating the principle of loose coupling.
   2. Inflexibility in Inheritance: While inheritance is leveraged to derive specialized
   CollisionStrategy objects in BrickerGameManager, it may lead to inflexibility if the
   inheritance hierarchy becomes too rigid. Changes in the inheritance structure could
   necessitate modifications in both BrickerGameManager and BasicCollisionStrategy,
   increasing code complexity and maintenance overhead.

2) I chose to implement two classes to manage life in the game. The Heart class inherits from GameObject,
    encapsulating the graphical representation of a single life unit, adhering to the principle of
    inheritance. It inherits common properties and behaviors necessary for graphical rendering.
    Meanwhile, the HeartsManager class encapsulates the logic for managing the player's life count,
    utilizing an instance of BrickerGameManager. This class abstracts the implementation details and
    provides a cohesive interface for interaction, relying on Heart for graphical representation and
    on BrickerGameManager for game state management. HeartsManager contains instances of Heart objects
    and relies on BrickerGameManager for game state management, utilizing composition to manage multiple
    heart objects efficiently. This composition relationship enables HeartsManager to orchestrate the
    interaction between individual Heart objects and the broader game environment. Additionally,
    BrickerGameManager contains methods and data structures necessary for managing game objects,
    including hearts, effectively encapsulating game state management within the game manager.
    The structured implementation and class relationships in the Heart and HeartsManager classes
    offer numerous advantages, including modularity, encapsulation, and scalability. This design
    approach ensures a robust and flexible system for managing the player's life count in the game,
    enhancing code maintainability and adaptability to changing requirements.

3) The choice between the strategies is made using a factory class that selects a strategy based on
    a predefined probability. Each strategy contains an instance of Brickergamemanager and invokes
    appropriate methods to perform the required actions. This is a composition relationship facilitated
    by the extended API of Brickergamemanager.
   Extra Ball:
       The strategy relies on a method in Brickergamemanager that simply generates two instances of puck
       balls on the screen, without the need for a separate class. There's an automatic update that removes
       balls that exit the board, simplifying management.
   Extra Life:
        The strategy is based on the relationships between the Heart, HeartsManager, and Brickergamemanager
        classes. Additional methods were added to each without the need for a new class.
   Extra Paddle:
        This strategy utilizes methods in Brickergamemanager to show and hide ExtraPaddle objects held
        as a field within Brickergamemanager. To facilitate this, an ExtraPaddle class was added,
        inheriting from Paddle and extending it to handle collisions with balls.
   Camera Change:
        The strategy is based on a method in Brickergamemanager that simply generates two instances of puck
        balls on the screen, without the need for a separate class. A field was added to Brickergamemanager
        to track the number of collisions.
   Advantages of my structure:
   Abstraction and Encapsulation:
        Each strategy encapsulates specific functionalities within dedicated classes, promoting code
        modularity and reusability.
   Dependency Management:
        Strategies rely on methods provided by Brickergamemanager, establishing clear dependencies and
        enhancing code cohesion.
   Simplicity and Flexibility:
        By leveraging existing classes and extending their functionality through inheritance and
        polymorphism, the implementation remains concise and adaptable to future changes.

4) I added a unique method to the CollisionStrategyFactory that returns an array of strategies.
    Inside this method, after generating two random numbers, it is decided whether to expand the
    number of strategies to three. Consequently, the DoubleCollisionStrategies class receives a
    ready-made array of the appropriate length. Using a composition relationship, it invokes the
    onCollision method on each element of the array without depending on its size.
   The advantage of this approach is that future expansion can be achieved with minimal
   code changes within a single method, thus maintaining flexibility. This design ensures
   that the dependency between the factory and the DoubleCollisionStrategies class remains
   minimal. Overall, this approach enhances code flexibility and maintainability,
   allowing for easy scalability without significant modifications to the existing codebase.

5) I added 6 methods to the BrickerGameManagar API:
    boolean removeObject(object, layer);
    void addObject(object, layer);
    void createPuckBalls();
    void locateExtraPaddle();
    void changCameraMode();
    void createExtraLifv();
    The addition of these methods to the BrickerGameManager API enhances its functionality and facilitates
    the utilization of various game strategies and the HeartManager class through the composition of
    BrickerGameManager appearances.